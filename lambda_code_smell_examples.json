{
  "Lambda Monolith": {
    "bad_example": "# BAD: Monolithic Lambda doing everything\nimport json\nimport boto3\n\ndef lambda_handler(event, context):\n    event_type = event.get('type')\n\n    if event_type == 'user_registration':\n        # User registration logic\n        user_data = event['user']\n        dynamodb = boto3.resource('dynamodb')\n        table = dynamodb.Table('Users')\n        table.put_item(Item=user_data)\n\n        # Send welcome email\n        ses = boto3.client('ses')\n        ses.send_email(\n            Source='noreply@example.com',\n            Destination={'ToAddresses': [user_data['email']]},\n            Message={\n                'Subject': {'Data': 'Welcome!'},\n                'Body': {'Text': {'Data': 'Welcome to our service'}}\n            }\n        )\n        return {'statusCode': 200, 'body': 'User registered'}\n\n    elif event_type == 'order_processing':\n        # Order processing logic\n        order = event['order']\n        # ... 50+ lines of order logic ...\n        return {'statusCode': 200, 'body': 'Order processed'}\n\n    elif event_type == 'inventory_update':\n        # Inventory update logic  \n        # ... 40+ lines of inventory logic ...\n        return {'statusCode': 200, 'body': 'Inventory updated'}\n\n    elif event_type == 'report_generation':\n        # Report generation logic\n        # ... 60+ lines of report logic ...\n        return {'statusCode': 200, 'body': 'Report generated'}\n\n    else:\n        return {'statusCode': 400, 'body': 'Unknown event type'}",
    "good_example": "# GOOD: Separate Lambda functions\n# user_registration_lambda.py\nimport json\nimport boto3\n\ndynamodb = boto3.resource('dynamodb')\nses = boto3.client('ses')\n\ndef lambda_handler(event, context):\n    user_data = event['user']\n\n    # Save user\n    table = dynamodb.Table('Users')\n    table.put_item(Item=user_data)\n\n    # Send welcome email\n    ses.send_email(\n        Source='noreply@example.com',\n        Destination={'ToAddresses': [user_data['email']]},\n        Message={\n            'Subject': {'Data': 'Welcome!'},\n            'Body': {'Text': {'Data': 'Welcome to our service'}}\n        }\n    )\n\n    return {'statusCode': 200, 'body': json.dumps('User registered')}\n\n# order_processing_lambda.py\ndef lambda_handler(event, context):\n    order = event['order']\n    # Focused order processing logic\n    return {'statusCode': 200, 'body': json.dumps('Order processed')}\n\n# inventory_update_lambda.py  \ndef lambda_handler(event, context):\n    # Focused inventory logic\n    return {'statusCode': 200, 'body': json.dumps('Inventory updated')}\n\n# Use EventBridge rules to route events to appropriate Lambda"
  },
  "Global Variable Reinitialization": {
    "bad_example": "# BAD: Reinitializing on every invocation\nimport json\nimport boto3\n\ndef lambda_handler(event, context):\n    # Creating new client on EVERY invocation - SLOW!\n    dynamodb = boto3.resource('dynamodb')\n    table = dynamodb.Table('Orders')\n\n    # Fetching config on EVERY invocation - EXPENSIVE!\n    ssm = boto3.client('ssm')\n    response = ssm.get_parameter(Name='/app/config')\n    config = json.loads(response['Parameter']['Value'])\n\n    # Process with config\n    order_id = event['order_id']\n    order = table.get_item(Key={'id': order_id})\n\n    return {'statusCode': 200, 'body': json.dumps('Success')}",
    "good_example": "# GOOD: Initialize outside handler, reuse across invocations\nimport json\nimport boto3\n\n# Initialize ONCE per execution context\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table('Orders')\nssm = boto3.client('ssm')\n\n# Cache configuration\nconfig = None\n\ndef get_config():\n    global config\n    if config is None:\n        response = ssm.get_parameter(Name='/app/config')\n        config = json.loads(response['Parameter']['Value'])\n    return config\n\ndef lambda_handler(event, context):\n    # Reuse connections and cached config\n    app_config = get_config()\n\n    order_id = event['order_id']\n    order = table.get_item(Key={'id': order_id})\n\n    return {'statusCode': 200, 'body': json.dumps('Success')}"
  },
  "Missing Error Handling": {
    "bad_example": "# BAD: No error handling\nimport json\nimport boto3\n\ndef lambda_handler(event, context):\n    dynamodb = boto3.resource('dynamodb')\n    table = dynamodb.Table('Users')\n\n    # What if this fails? Silent failure!\n    user_id = event['userId']\n    table.delete_item(Key={'id': user_id})\n\n    # What if SQS is down? Exception crashes function!\n    sqs = boto3.client('sqs')\n    sqs.send_message(\n        QueueUrl='https://sqs.us-east-1.amazonaws.com/123/queue',\n        MessageBody=json.dumps({'deleted': user_id})\n    )\n\n    return {'statusCode': 200}",
    "good_example": "# GOOD: Proper error handling with logging and DLQ\nimport json\nimport boto3\nimport logging\nfrom botocore.exceptions import ClientError\n\n# Configure structured logging\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndynamodb = boto3.resource('dynamodb')\nsqs = boto3.client('sqs')\n\ndef lambda_handler(event, context):\n    correlation_id = context.request_id\n\n    try:\n        # Validate input\n        if 'userId' not in event:\n            logger.error(f\"Missing userId in event\", extra={'correlation_id': correlation_id})\n            return {'statusCode': 400, 'body': json.dumps('Missing userId')}\n\n        user_id = event['userId']\n        logger.info(f\"Processing delete for user {user_id}\", \n                   extra={'correlation_id': correlation_id, 'user_id': user_id})\n\n        # Delete with error handling\n        table = dynamodb.Table('Users')\n        try:\n            table.delete_item(Key={'id': user_id})\n            logger.info(f\"User {user_id} deleted\", extra={'user_id': user_id})\n        except ClientError as e:\n            logger.error(f\"DynamoDB error: {e.response['Error']['Message']}\", \n                        extra={'user_id': user_id, 'error_code': e.response['Error']['Code']})\n            raise  # Re-raise to trigger retry/DLQ\n\n        # Send notification with retry\n        try:\n            sqs.send_message(\n                QueueUrl='https://sqs.us-east-1.amazonaws.com/123/queue',\n                MessageBody=json.dumps({'deleted': user_id})\n            )\n        except ClientError as e:\n            logger.error(f\"SQS error: {e.response['Error']['Message']}\", \n                        extra={'user_id': user_id})\n            # Don't fail entire operation if notification fails\n\n        return {'statusCode': 200, 'body': json.dumps({'deleted': user_id})}\n\n    except Exception as e:\n        logger.exception(f\"Unexpected error\", extra={'correlation_id': correlation_id})\n        raise  # Trigger DLQ for async invocations"
  },
  "Hardcoded Configuration": {
    "bad_example": "# BAD: Hardcoded values\nimport boto3\n\ndef lambda_handler(event, context):\n    # Hardcoded API key - SECURITY RISK!\n    api_key = \"sk-1234567890abcdef\"\n\n    # Hardcoded database - can't change without redeploying\n    table_name = \"prod-users-table\"\n\n    # Hardcoded region\n    s3 = boto3.client('s3', region_name='us-east-1')\n    bucket_name = \"my-app-bucket\"\n\n    # Use these values...\n    return {'statusCode': 200}",
    "good_example": "# GOOD: Environment variables and Secrets Manager\nimport os\nimport json\nimport boto3\nfrom botocore.exceptions import ClientError\n\n# Get non-sensitive config from environment variables\nTABLE_NAME = os.environ['TABLE_NAME']\nBUCKET_NAME = os.environ['BUCKET_NAME']\nSECRET_NAME = os.environ['SECRET_NAME']\n\nsecrets_client = boto3.client('secretsmanager')\ns3 = boto3.client('s3')\n\n# Cache secrets\n_secrets = None\n\ndef get_secrets():\n    global _secrets\n    if _secrets is None:\n        try:\n            response = secrets_client.get_secret_value(SecretId=SECRET_NAME)\n            _secrets = json.loads(response['SecretString'])\n        except ClientError as e:\n            raise Exception(f\"Failed to retrieve secrets: {e}\")\n    return _secrets\n\ndef lambda_handler(event, context):\n    # Get API key from Secrets Manager\n    secrets = get_secrets()\n    api_key = secrets['api_key']\n\n    # Use environment variables\n    dynamodb = boto3.resource('dynamodb')\n    table = dynamodb.Table(TABLE_NAME)\n\n    # Use configured bucket\n    s3.list_objects_v2(Bucket=BUCKET_NAME)\n\n    return {'statusCode': 200}\n\n# Deploy with:\n# aws lambda update-function-configuration \\\\\n#   --function-name my-function \\\\\n#   --environment Variables=\"{TABLE_NAME=users,BUCKET_NAME=data,SECRET_NAME=app/secrets}\""
  }
}